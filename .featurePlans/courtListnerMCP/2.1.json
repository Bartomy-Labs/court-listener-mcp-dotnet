{
  "taskId": "2.1",
  "title": "CourtListener HTTP Client Service",
  "phase": "2",
  "phaseTitle": "Core Services & HTTP Client",
  "taskNumber": 1,
  "totalTasksInPhase": 2,
  "complexity": "complex",
  "objective": "Create typed HTTP client service for CourtListener API communication with Polly resilience policies",

  "contextManagement": {
    "isFirstInPhase": true,
    "isLastInPhase": false,
    "requiresContextLoad": true,
    "loadContextFrom": "ingestion_phaseBoundary_phase1_20251006.md",
    "phaseBoundaryInstructions": null
  },

  "codebaseVerificationEvidence": {
    "verifiedFiles": [
      ".featurePlans/courtListnerMCP/CourtListnerMCPServer.md (lines 98-143)",
      "CourtListener.MCP.Server/Configuration/CourtListenerOptions.cs (from Task 1.3)"
    ],
    "verifiedMethods": [],
    "assumptionAudit": {
      "assumptionLanguageDetected": false,
      "assumptionCount": 0,
      "confidence": "HIGH",
      "notes": "All specifications verified from plan document. GAP #1 decision (Polly) integrated with test scenarios."
    }
  },

  "agentInstructions": "**OBJECTIVE**: Create a robust HTTP client service for CourtListener API with comprehensive Polly resilience policies.\n\n**CRITICAL CONTEXT**: This is the core service that all MCP tools will use. Implements GAP #1 decision with retry, circuit breaker, and rate limit handling.\n\n**PREREQUISITES**:\n- Phase 1 tasks completed (CourtListenerOptions exists, Polly packages installed)\n- Navigate to `CourtListener.MCP.Server/Services/` directory\n\n**EXECUTION STEPS**:\n\n1. **Create ICourtListenerClient Interface**:\n   - Create file: `Services/ICourtListenerClient.cs`\n   - Interface methods:\n     ```csharp\n     public interface ICourtListenerClient\n     {\n         Task<TResponse?> GetAsync<TResponse>(string endpoint, CancellationToken cancellationToken = default);\n         Task<TResponse?> PostAsync<TRequest, TResponse>(string endpoint, TRequest request, CancellationToken cancellationToken = default);\n         Task<TResponse?> PostFormAsync<TResponse>(string endpoint, Dictionary<string, string> formData, CancellationToken cancellationToken = default);\n     }\n     ```\n   - Add XML documentation for each method\n   - Verify: File compiles\n\n2. **Create CourtListenerClient Implementation**:\n   - Create file: `Services/CourtListenerClient.cs`\n   - Inject: `HttpClient` (from IHttpClientFactory), `IOptions<CourtListenerOptions>`, `ILogger<CourtListenerClient>`\n   - Implement all 3 interface methods:\n     - `GetAsync<TResponse>` - GET requests with deserialization\n     - `PostAsync<TRequest, TResponse>` - POST JSON requests\n     - `PostFormAsync<TResponse>` - POST form-encoded data\n   - Add request/response logging with Serilog structured properties:\n     - Log request: URL, method, parameters (sanitized)\n     - Log response: status code, duration, size\n     - Log errors: exception details, request context\n   - Handle HttpClient exceptions gracefully\n   - Return null on 404 (not found is valid response)\n   - Throw on other errors (let Polly handle retries)\n   - Verify: Implementation compiles\n\n3. **Create Service Registration Extension Method**:\n   - Create file: `Configuration/ServiceCollectionExtensions.cs`\n   - Method: `AddCourtListenerClient(this IServiceCollection services, IConfiguration configuration)`\n   - Implementation:\n     ```csharp\n     public static IServiceCollection AddCourtListenerClient(this IServiceCollection services, IConfiguration configuration)\n     {\n         // Bind CourtListenerOptions\n         services.Configure<CourtListenerOptions>(configuration.GetSection(\"CourtListener\"));\n\n         // Add typed HTTP client with Polly policies\n         services.AddHttpClient<ICourtListenerClient, CourtListenerClient>((sp, client) =>\n         {\n             var options = sp.GetRequiredService<IOptions<CourtListenerOptions>>().Value;\n             client.BaseAddress = new Uri(options.BaseUrl);\n             client.Timeout = TimeSpan.FromSeconds(options.TimeoutSeconds);\n             client.DefaultRequestHeaders.Add(\"Authorization\", $\"Token {options.ApiKey}\");\n             client.DefaultRequestHeaders.Add(\"User-Agent\", \"CourtListener-MCP-DotNet/1.0\");\n         })\n         .AddPolicyHandler(GetRetryPolicy())\n         .AddPolicyHandler(GetCircuitBreakerPolicy());\n\n         return services;\n     }\n     ```\n\n4. **Implement Polly Retry Policy** (GAP #1):\n   - Add private static method: `GetRetryPolicy()`\n   - Configuration:\n     - 3 retry attempts\n     - Exponential backoff: 2s, 4s, 8s\n     - Retry on: 5xx errors, 408 timeout, network failures\n     - DO NOT retry on: 404, 401, 403 (permanent errors)\n     - Handle 429 rate limit: Respect Retry-After header (or default 60s)\n   - Log each retry attempt with context\n   - Policy example:\n     ```csharp\n     private static IAsyncPolicy<HttpResponseMessage> GetRetryPolicy()\n     {\n         return HttpPolicyExtensions\n             .HandleTransientHttpError() // 5xx and 408\n             .Or<HttpRequestException>()\n             .OrResult(msg => msg.StatusCode == (HttpStatusCode)429) // Rate limit\n             .WaitAndRetryAsync(\n                 retryCount: 3,\n                 sleepDurationProvider: (retryAttempt, outcome, context) =>\n                 {\n                     // Check for Retry-After header on 429\n                     if (outcome.Result?.StatusCode == (HttpStatusCode)429)\n                     {\n                         var retryAfter = outcome.Result.Headers.RetryAfter;\n                         if (retryAfter?.Delta != null)\n                             return retryAfter.Delta.Value;\n                         if (retryAfter?.Date != null)\n                             return retryAfter.Date.Value - DateTimeOffset.UtcNow;\n                         return TimeSpan.FromSeconds(60); // Default\n                     }\n                     // Exponential backoff: 2s, 4s, 8s\n                     return TimeSpan.FromSeconds(Math.Pow(2, retryAttempt));\n                 },\n                 onRetryAsync: (outcome, timespan, retryAttempt, context) =>\n                 {\n                     // Log retry with structured properties\n                     var logger = context.GetLogger();\n                     logger?.LogWarning(\n                         \"Retry {RetryAttempt} after {Delay}s due to {StatusCode}\",\n                         retryAttempt,\n                         timespan.TotalSeconds,\n                         outcome.Result?.StatusCode ?? 0\n                     );\n                     return Task.CompletedTask;\n                 }\n             );\n     }\n     ```\n\n5. **Implement Polly Circuit Breaker Policy** (GAP #1):\n   - Add private static method: `GetCircuitBreakerPolicy()`\n   - Configuration:\n     - Break after: 5 consecutive failures\n     - Break duration: 60 seconds\n     - Handle same errors as retry policy\n   - Log circuit breaker state changes (Open, HalfOpen, Closed)\n   - Policy example:\n     ```csharp\n     private static IAsyncPolicy<HttpResponseMessage> GetCircuitBreakerPolicy()\n     {\n         return HttpPolicyExtensions\n             .HandleTransientHttpError()\n             .Or<HttpRequestException>()\n             .CircuitBreakerAsync(\n                 handledEventsAllowedBeforeBreaking: 5,\n                 durationOfBreak: TimeSpan.FromSeconds(60),\n                 onBreak: (outcome, duration) =>\n                 {\n                     // Log circuit breaker opened\n                 },\n                 onReset: () =>\n                 {\n                     // Log circuit breaker closed\n                 },\n                 onHalfOpen: () =>\n                 {\n                     // Log circuit breaker half-open (testing)\n                 }\n             );\n     }\n     ```\n\n6. **Verify Implementation**:\n   - Run: `dotnet build`\n   - Verify: No compilation errors\n   - Verify: All 3 interface methods implemented\n   - Verify: Authorization header format: `Token {ApiKey}`\n   - Verify: Retry policy configured with exponential backoff\n   - Verify: Circuit breaker configured with 5 failure threshold\n   - Verify: Rate limit handling respects Retry-After header\n\n**DELIVERABLES**:\n- `Services/ICourtListenerClient.cs` - Interface with 3 methods\n- `Services/CourtListenerClient.cs` - Implementation with logging\n- `Configuration/ServiceCollectionExtensions.cs` - DI registration with Polly\n- Polly retry policy: 3 attempts, 2s/4s/8s backoff\n- Polly circuit breaker: 5 failures, 60s break\n- Rate limit handling: 429 + Retry-After header support\n\n**VERIFICATION CHECKLIST**:\n- [ ] ICourtListenerClient interface exists with 3 methods\n- [ ] CourtListenerClient implements interface\n- [ ] HttpClient injected via IHttpClientFactory\n- [ ] Authorization header format: `Token {ApiKey}`\n- [ ] User-Agent header: `CourtListener-MCP-DotNet/1.0`\n- [ ] Timeout configured from CourtListenerOptions (30s default)\n- [ ] Retry policy: 3 attempts, exponential backoff (2s, 4s, 8s)\n- [ ] Retry only on transient errors (5xx, 408, network)\n- [ ] NO retry on permanent errors (404, 401, 403)\n- [ ] Rate limit (429) respects Retry-After header\n- [ ] Circuit breaker: 5 failures → 60s open\n- [ ] Structured logging with request/response context\n- [ ] AddCourtListenerClient() extension method exists\n- [ ] Project builds successfully",

  "successCriteria": [
    "HTTP client properly configured with base URL and headers",
    "Authorization token automatically added to requests: `Token {ApiKey}`",
    "Polly retry policy configured: 3 attempts, exponential backoff (2s, 4s, 8s)",
    "Polly circuit breaker configured: 5 failures → 60s open",
    "Rate limit (429) handling respects Retry-After header",
    "Service registered in DI container via AddCourtListenerClient()",
    "Structured logging for all requests/responses with context",
    "Test scenarios pass: transient errors recover, permanent errors fail immediately, rate limits respected, circuit breaker opens/closes correctly"
  ],

  "criticalAnchors": [
    "MUST use IHttpClientFactory for proper HTTP client management",
    "MUST implement Polly resilience policies per GAP #1 decision",
    "Retry policy: 3 attempts, exponential backoff (2s, 4s, 8s)",
    "Circuit breaker: 5 failures → 60s open circuit",
    "Rate limit aware: Respect 429 + Retry-After header",
    "Retry ONLY transient errors (5xx, 408, network failures)",
    "DO NOT retry permanent errors (404, 401, 403)",
    "Authorization header format: `Token {ApiKey}` (not Bearer)",
    "Timeout: 30 seconds default (from CourtListenerOptions)",
    "User-Agent: `CourtListener-MCP-DotNet/1.0`",
    "Structured logging for all HTTP operations"
  ],

  "associatedArtifacts": [
    {
      "type": "interface",
      "path": "CourtListener.MCP.Server/Services/ICourtListenerClient.cs",
      "description": "HTTP client interface with GetAsync, PostAsync, PostFormAsync methods"
    },
    {
      "type": "class",
      "path": "CourtListener.MCP.Server/Services/CourtListenerClient.cs",
      "description": "HTTP client implementation with Polly policies and logging"
    },
    {
      "type": "class",
      "path": "CourtListener.MCP.Server/Configuration/ServiceCollectionExtensions.cs",
      "description": "DI registration extension with AddCourtListenerClient() method"
    }
  ],

  "executionControls": {
    "estimatedDuration": "30-45 minutes",
    "requiresUserInput": false,
    "canRunOffline": true,
    "requiresExternalServices": false,
    "prerequisiteTasks": ["1.1", "1.2", "1.3"],
    "blockedBy": [],
    "pauseBeforeExecution": false,
    "pauseAfterExecution": false
  },

  "gapDecisionReferences": [
    {
      "gapId": "GAP #1",
      "gapTitle": "HTTP Client Retry and Resilience Strategy",
      "decision": "Polly with Comprehensive Resilience Policies",
      "implementation": "Retry policy (3 attempts, exponential backoff) + Circuit breaker (5 failures, 60s) + Rate limit handling (429 + Retry-After)"
    }
  ],

  "metadata": {
    "generatedAt": "2025-10-06T18:30:00Z",
    "generatedBy": "L.E.A.S.H. Ingestion v3.2.0-git",
    "planSource": ".featurePlans/courtListnerMCP/CourtListnerMCPServer.md",
    "confidenceLevel": "HIGH"
  }
}
